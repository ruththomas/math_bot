package actors

import actors.LevelGenerationActor.{GetGridMap, GetStep}
import actors.StatsActor.{StatsDoneUpdating, UpdateStats}
import actors.messages._
import akka.actor.{Actor, ActorRef, Props}
import akka.pattern.ask
import akka.util.Timeout
import compiler.operations.NoOperation
import compiler.processor.{Frame, Processor, Register, RobotLocation}
import compiler.{Compiler, GridAndProgram, Point}
import controllers.MathBotCompiler
import javax.inject.Inject
import loggers.MathBotLogger
import model.PlayerTokenDAO
import model.models.{FuncToken, GridMap, Problem, Stats}
import play.api.libs.concurrent.Execution.Implicits.defaultContext
import types.TokenId
import utils.CompilerConfiguration

import scala.concurrent.Future
import scala.concurrent.duration._

class CompilerActor @Inject()(out: ActorRef, tokenId: TokenId)(
    playerTokenDAO: PlayerTokenDAO,
    statsActor: ActorRef,
    levelActor: ActorRef,
    logger: MathBotLogger,
    config: CompilerConfiguration
) extends Actor {

  import MathBotCompiler._

  case class ProgramState(stream: Stream[Frame],
                          iterator: Iterator[Frame],
                          grid: GridMap,
                          program: GridAndProgram,
                          clientFrames: List[ClientFrame] = List.empty[ClientFrame],
                          stepCount: Int = 0,
                          leftoverFrame: Option[Frame] = None,
                          exitOnSuccess: Boolean = false) {
    def addSteps(steps: Int): ProgramState = this.copy(stepCount = this.stepCount + steps)
  }
  implicit val timeout: Timeout = 5000.minutes

  private val className = s"CompilerActor(${context.self.path.toSerializationFormat})"

  private def createFrames(leadingFrames: List[Frame]) = {

    val frames = leadingFrames.map(_.withMinimalGrid()).map(ClientFrame(_))

    frames
  }

  private def checkForSuccess(programState: ProgramState, frame: Frame): Boolean =
    programState.grid.success(frame, programState.program.problem)

  private def createLastFrame(programState: ProgramState, frame: Frame) = {
    // Check to see if the last frame generated by the processor matches the problem check
    for {
      // Update stats, and get the updated stats
      stats <- (statsActor ? UpdateStats(success = checkForSuccess(programState, frame), tokenId = tokenId))
        .mapTo[Either[Stats, ActorFailed]]
        .map(_.left.get)
      // Gather the prepared step data
      stepData <- (levelActor ? GetStep(stats.level, stats.step, Some(tokenId)))
        .mapTo[Either[PreparedStepData, ActorFailed]]
        .map(_.left.get)
    } yield {
      if (checkForSuccess(programState, frame)) {
        List(MathBotCompiler.ClientFrame.success(frame, stats, stepData))
      } else {
        List(MathBotCompiler.ClientFrame.failure(frame, stats, stepData))
      }
    }
  }

  private def createLastFromFromNothing() = {
    for {
      // Update stats, and get the updated stats
      stats <- (statsActor ? UpdateStats(success = false, tokenId = tokenId))
        .mapTo[Either[Stats, ActorFailed]]
        .map(_.left.get)
      // Gather the prepared step data
      stepData <- (levelActor ? GetStep(stats.level, stats.step, Some(tokenId)))
        .mapTo[Either[PreparedStepData, ActorFailed]]
        .map(_.left.get)
    } yield {
      MathBotCompiler.ClientFrame(ClientRobotState(Point(0, 0), "0", List.empty[String]),
                                  "failure",
                                  Some(stats),
                                  Some(stepData))
    }
  }

  private def sendFrames(programState: ProgramState, clientFrames: List[ClientFrame]): Unit = {
    out ! CompilerOutput(clientFrames, programState.grid.problem)
  }

  override def receive: Receive = createCompile()

  def createCompile(): Receive = {
    case CompilerExecute(steps, problem) =>
      self ! CompilerCreate(steps, problem)

    case CompilerCreate(steps, problem) =>
      logger.LogInfo(className, "Creating new compiler.")

      for {
        tokenList <- playerTokenDAO.getToken(tokenId)
        grid <- (levelActor ? GetGridMap(tokenList)).mapTo[GridMap]
      } yield {
        for {
          token <- tokenList
          main = token.lambdas.head.main
          funcs = token.lambdas.head.activeFuncs ++ token.lambdas.head.inactiveActives.getOrElse(List.empty[FuncToken])
          commands = token.lambdas.head.cmds
          program <- Compiler.compile(main, funcs, commands, grid, problem)
        } yield {
          val processor = Processor(program)
          val stream = processor.execute()
          context.become(
            compileContinue(
              ProgramState(stream = stream,
                           iterator = stream.iterator,
                           grid = grid,
                           program = program,
                           exitOnSuccess = grid.evalEachFrame)
            )
          )
          self ! CompilerContinue(steps)
        }
      }
    case CompilerContinue(_) =>
      // We see this in production and don't know why the client is still sending continues after the actor
      // has signaled end of program.  So we try to create a fake last frame.
      logger.LogDebug("CompilerActor", "Continue received during create state.")
      for {
        lastFrame <- createLastFromFromNothing()
      } yield out ! CompilerOutput(List(lastFrame), Problem(""))
  }

  def compileContinue(currentCompiler: ProgramState): Receive = {

    case CompilerExecute(steps, _) =>
      self ! CompilerContinue(steps)

    case CompilerContinue(steps) =>
      logger.LogInfo(className,
                     s"Stepping compiler for $steps steps with actor ${context.self.path.toSerializationFormat}")
      // filter out non-robot frames (eg function calls and program start)
      val maxStepsReached = config.maxProgramSteps < currentCompiler.stepCount + steps
      val takeSteps = if (maxStepsReached) config.maxProgramSteps - currentCompiler.stepCount else steps
      val robotFrames = currentCompiler.iterator
        .filter(f => {
          f.robotLocation.isDefined
        })
        .take(takeSteps)
        .toList

      val executeSomeFrames = (if (currentCompiler.exitOnSuccess) {
                                 if (currentCompiler.leftoverFrame.exists(lf => checkForSuccess(currentCompiler, lf))) {
                                   Seq.empty[Frame] // When the leftover is the success frame, don't return addtional frames
                                 } else {
                                   // Generate a temporary index for the program frames and search for a success frame.
                                   // Truncate the frames to the first successful frame
                                   val frames = robotFrames.zipWithIndex
                                   frames
                                     .find(frame => checkForSuccess(currentCompiler, frame._1))
                                     .map(successFrame => frames.take(successFrame._2 + 1))
                                     .getOrElse(frames)
                                     .map(f => f._1)
                                 }
                               } else {
                                 robotFrames
                               }).toList

      // if the compiler generated less frames than requested we assume the program completed
      val programCompleted = executeSomeFrames.length < takeSteps || maxStepsReached

      // This logic is done this way for now because the client has to query to get group of frames and will hang
      // if a query never responds with a frame. Eventually this gets replaced with an async stream of frames coming
      // from the compiler that will be controlled with back pressure message coming from the client.
      (currentCompiler.leftoverFrame, executeSomeFrames) match {
        case (None, List(frame)) =>
          // When the compiler generates a single frame, assume its the last frame.
          for {
            lastFrame <- createLastFrame(currentCompiler, frame)
          } yield sendFrames(currentCompiler, lastFrame)
          context.become(createCompile())
        case (None, leadingFrames :+ last) if !programCompleted =>
          // More than one frame, send the leading frames and save the last frame for the next request
          sendFrames(currentCompiler, createFrames(leadingFrames))
          context.become(
            compileContinue(currentCompiler.copy(leftoverFrame = Some(last)).addSteps(takeSteps))
          )
        case (None, leadingFrames :+ last) if programCompleted =>
          // When short the requested frames, assume the program has finished and compute the last frame too **
          for {
            lastFrame <- createLastFrame(currentCompiler, last)
          } yield sendFrames(currentCompiler, createFrames(leadingFrames) ++ lastFrame)
          context.become(
            createCompile()
          )
        case (Some(leftover), leadingFrames :+ last) if !programCompleted =>
          // With a leftover, and last, this is executing somewhere in the middle of the program.
          sendFrames(currentCompiler, createFrames(leftover +: leadingFrames))
          context.become(
            compileContinue(currentCompiler.copy(leftoverFrame = Some(last)).addSteps(takeSteps))
          )
        case (Some(leftover), leadingFrames :+ last) if programCompleted =>
          // With the program completed, we send all the remaining frames
          for {
            lastFrame <- createLastFrame(currentCompiler, last)
          } yield sendFrames(currentCompiler, createFrames(leftover +: leadingFrames) ++ lastFrame)
          context.become(createCompile())
        case (Some(leftover), Nil) =>
          // The compiler generates no more frames, so the leftover is now the last.
          for {
            lastFrame <- createLastFrame(currentCompiler, leftover)
          } yield sendFrames(currentCompiler, lastFrame)
          context.become(createCompile())
        case (Some(leftover), List(last)) =>
          // The compiler generated one more frame, and there was one leftover, send both frames
          for {
            lastFrame <- createLastFrame(currentCompiler, last)
          } yield sendFrames(currentCompiler, createFrames(List(leftover)) ++ lastFrame)
          context.become(createCompile())
        case (None, Nil) =>
          // It's an empty program, or one that consists of only empty functions
          for {
            lastFrame <- createLastFrame(currentCompiler,
                                         Frame(NoOperation(), Register(), currentCompiler.program.grid, None, None))
          } yield sendFrames(currentCompiler, lastFrame)
          context.become(createCompile())
      }

    case _: CompilerHalt =>
      logger.LogInfo(className, "Compiler halted")
      context.become(createCompile())
      out ! CompilerHalted()

    case Left(_: StatsDoneUpdating) =>
      logger.LogInfo(className, s"Stats updated successfully. token_id:$tokenId")

    case Right(invalidJson: ActorFailed) =>
      logger.LogFailure(className, invalidJson.msg)
      self ! invalidJson.msg

    case _ => out ! ActorFailed("Unknown command submitted to compiler")
  }

  override def postStop() = {
    logger.LogInfo(className, "Actor Stopped")
  }
}

object CompilerActor {
  def props(out: ActorRef,
            tokenId: String,
            playerTokenDAO: PlayerTokenDAO,
            statsActor: ActorRef,
            levelActor: ActorRef,
            logger: MathBotLogger,
            config: CompilerConfiguration) =
    Props(new CompilerActor(out, tokenId)(playerTokenDAO, statsActor, levelActor, logger, config))
}
