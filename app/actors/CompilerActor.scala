package actors

import actors.LevelGenerationActor.{GetGridMap, GetStep}
import actors.StatsActor.{StatsDoneUpdating, UpdateStats}
import actors.messages._
import akka.actor.{Actor, ActorRef, Props}
import akka.pattern.ask
import akka.util.Timeout
import compiler.processor.{Frame, Processor}
import compiler.{Compiler, GridAndProgram}
import controllers.MathBotCompiler
import javax.inject.Inject
import loggers.MathBotLogger
import model.PlayerTokenModel
import model.models.{GridMap, Stats}
import play.api.libs.concurrent.Execution.Implicits.defaultContext
import play.modules.reactivemongo.ReactiveMongoApi
import utils.CompilerConfiguration

import scala.concurrent.duration._

class CompilerActor @Inject()(out: ActorRef, tokenId: String)(
    val reactiveMongoApi: ReactiveMongoApi,
    statsActor: ActorRef,
    levelActor: ActorRef,
    logger: MathBotLogger,
    config: CompilerConfiguration
) extends Actor
    with PlayerTokenModel {

  import MathBotCompiler._

  case class ProgramState(stream: Stream[Frame],
                          iterator: Iterator[Frame],
                          grid: GridMap,
                          program: GridAndProgram,
                          clientFrames: List[ClientFrame] = List.empty[ClientFrame],
                          stepCount: Int = 0,
                          leftoverFrame: Option[Frame] = None,
                          exitOnSuccess: Boolean = false) {
    def addSteps(steps: Int): ProgramState = this.copy(stepCount = this.stepCount + steps)
  }

  implicit val timeout: Timeout = 5000.minutes

  private val className = "CompilerActor"

  private def createFrames(leadingFrames: List[Frame]) = {

    val frames = leadingFrames.map(_.withMinimalGrid()).map(ClientFrame(_))

    frames
  }

  private def checkForSuccess(programState: ProgramState, frame: Frame): Boolean =
    programState.grid.success(frame, programState.program.problem)

  private def createLastFrame(programState: ProgramState, frame: Frame) = {
    // Check to see if the last frame generated by the processor matches the problem check
    for {
      // Update stats, and get the updated stats
      stats <- (statsActor ? UpdateStats(success = checkForSuccess(programState, frame), tokenId = tokenId))
        .mapTo[Either[Stats, ActorFailed]]
        .map(_.left.get)
      // Gather the prepared step data
      stepData <- (levelActor ? GetStep(stats.level, stats.step, Some(tokenId)))
        .mapTo[Either[PreparedStepData, ActorFailed]]
        .map(_.left.get)
    } yield {
      if (checkForSuccess(programState, frame)) {
        List(MathBotCompiler.ClientFrame.success(frame, stats, stepData))
      } else {
        List(MathBotCompiler.ClientFrame.failure(frame, stats, stepData))
      }
    }
  }

  private def sendFrames(currentCompiler: Option[ProgramState],
                         programState: ProgramState,
                         clientFrames: List[ClientFrame]): Option[ProgramState] = {
    out ! CompilerOutput(clientFrames, programState.grid.problem)
    if (clientFrames.last.isSuccess()) {
      None
    } else if (clientFrames.last.isFailure()) {
      None
    } else {
      currentCompiler
    }
  }

  override def receive : Receive = compile()

  def compile(currentCompiler: Option[ProgramState] = None): Receive = {
    case CompilerExecute(steps, problem) =>
      // This approach to detecting a new program is deprecated. The client should now flag
      // new programs in the request json
      currentCompiler match {
        case Some(_) => self ! CompilerContinue(steps)
        case None => self ! CompilerCreate(steps, problem)
      }

    case CompilerCreate(steps, problem) =>
      logger.LogInfo(className, "Creating new compiler.")

      for {
        tokenList <- getToken(tokenId)
        grid <- (levelActor ? GetGridMap(tokenList)).mapTo[GridMap]
      } yield {
        for {
          token <- tokenList
          main = token.lambdas.head.main
          funcs = token.lambdas.head.activeFuncs
          commands = token.lambdas.head.cmds
          program <- Compiler.compile(main, funcs, commands, grid, problem)
        } yield {
          val processor = Processor(program)
          val stream = processor.execute()
          context.become(
            compile(
              Some(
                ProgramState(stream = stream,
                             iterator = stream.iterator,
                             grid = grid,
                             program = program,
                             exitOnSuccess = grid.evalEachFrame)
              )
            )
          )
          self ! CompilerContinue(steps)
        }
      }

    case CompilerContinue(steps) =>
      logger.LogInfo(className, s"Stepping compiler for $steps steps")
      for {
        programState <- currentCompiler
      } yield {
        // filter out non-robot frames (eg function calls and program start)
        val maxStepsReached = config.maxProgramSteps < programState.stepCount + steps
        val takeSteps = if (maxStepsReached) config.maxProgramSteps - programState.stepCount else steps
        val robotFrames = programState.iterator.filter(f => f.robotLocation.isDefined).take(takeSteps).toList

        val executeSomeFrames = (if (programState.exitOnSuccess) {
                                   if (programState.leftoverFrame.exists(lf => checkForSuccess(programState, lf))) {
                                     Seq.empty[Frame] // When the leftover is the success frame, don't return addtional frames
                                   } else {
                                     // Generate a temporary index for the program frames and search for a success frame.
                                     // Truncate the frames to the first successful frame
                                     val frames = robotFrames.zipWithIndex
                                     frames
                                       .find(frame => checkForSuccess(programState, frame._1))
                                       .map(successFrame => frames.take(successFrame._2 + 1))
                                       .getOrElse(frames)
                                       .map(f => f._1)
                                   }
                                 } else {
                                   robotFrames
                                 }).toList

        // if the compiler generated less frames than requested we assume the program completed
        val programCompleted = executeSomeFrames.length < takeSteps || maxStepsReached

        // This logic is done this way for now because the client has to query to get group of frames and will hang
        // if a query never responds with a frame. Eventually this gets replaced with an async stream of frames coming
        // from the compiler that will be controlled with back pressure message coming from the client.
        (currentCompiler.flatMap(_.leftoverFrame), executeSomeFrames) match {
          case (None, List(frame)) =>
            // When the compiler generates a single frame, assume its the last frame.
            for {
              lastFrame <- createLastFrame(programState, frame)
            } yield context.become(compile(sendFrames(currentCompiler, programState, lastFrame)))
          case (None, leadingFrames :+ last) if !programCompleted =>
            // More than one frame, send the leading frames and save the last frame for the next request
            context.become(
              compile(
                sendFrames(currentCompiler, programState, createFrames(leadingFrames))
                  .map(_.copy(leftoverFrame = Some(last)).addSteps(takeSteps))
              )
            )
          case (None, leadingFrames :+ last) if programCompleted =>
            // When short the requested frames, assume the program has finished and compute the last frame too **
            for {
              lastFrame <- createLastFrame(programState, last)
            } yield
              context.become(
                compile(sendFrames(currentCompiler, programState, createFrames(leadingFrames) ++ lastFrame))
              )
          case (Some(leftover), leadingFrames :+ last) if !programCompleted =>
            // With a leftover, and last, this is executing somewhere in the middle of the program.
            context.become(
              compile(
                sendFrames(currentCompiler, programState, createFrames(leftover +: leadingFrames))
                  .map(_.copy(leftoverFrame = Some(last)).addSteps(takeSteps))
              )
            )
          case (Some(leftover), leadingFrames :+ last) if programCompleted =>
            // With the program completed, we send all the remaining frames
            for {
              lastFrame <- createLastFrame(programState, last)
            } yield
              context.become(
                compile(sendFrames(currentCompiler, programState, createFrames(leftover +: leadingFrames) ++ lastFrame))
              )
          case (Some(leftover), Nil) =>
            // The compiler generates no more frames, so the leftover is now the last.
            for {
              lastFrame <- createLastFrame(programState, leftover)
            } yield context.become(compile(sendFrames(currentCompiler, programState, lastFrame)))
          case (Some(leftover), List(last)) =>
            // The compiler generated one more frame, and there was one leftover, send both frames
            for {
              lastFrame <- createLastFrame(programState, last)
            } yield
              context.become(
                compile(sendFrames(currentCompiler, programState, createFrames(List(leftover)) ++ lastFrame))
              )
          case (None, Nil) =>
          // This case does nothing, should never happen
        }
      }

    case _: CompilerHalt =>
      logger.LogInfo(className, "Compiler halted")
      context.become(compile())
      out ! CompilerHalted()

    case Left(_: StatsDoneUpdating) =>
      logger.LogInfo(className, s"Stats updated successfully. token_id:$tokenId")

    case Right(invalidJson: ActorFailed) =>
      logger.LogFailure(className, invalidJson.msg)
      self ! invalidJson.msg

    case _ => out ! ActorFailed("Unknown command submitted to compiler")
  }
}

object CompilerActor {
  def props(out: ActorRef,
            tokenId: String,
            reactiveMongoApi: ReactiveMongoApi,
            statsActor: ActorRef,
            levelActor: ActorRef,
            logger: MathBotLogger,
            config: CompilerConfiguration) =
    Props(new CompilerActor(out, tokenId)(reactiveMongoApi, statsActor, levelActor, logger, config))
}
